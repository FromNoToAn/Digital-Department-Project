# Документация по детектору остановки
Запустите скрипт для установки необходимых библиотек 
 ```
chmod +x install.bash
sudo ./install.bash
 ```

Скачайте архив с детектором.
Разархивируйте архив и перейдите в папку детектора
```
unzip RTK-Stop-Detector.zip
cd RTK-Stop-Detector
```

## Пример использования
```python
# Инициализация
python stopDetector.py --video_path './021.mp4' --drawing_mode 0
# для RTSP потока
python stopDetector.py --rtsp_url 'rtsp://admin:lavrentiev6@10.2.21.221/cam/realmonitor?channel=1&subtype=1' --drawing_mode 0
# или для Jetson
python3 stopDetector.py --video_path "./021_1.mp4" --drawing_mode 0
# для RTSP потока для Jetson
python3 stopDetector.py --rtsp_url 'rtsp://admin:lavrentiev6@10.2.21.221/cam/realmonitor?channel=1&subtype=1' --drawing_mode 
 ```

## Настройка для докера
```
docker build -t rtk-stop-detector:stop_detector .
docker run rtk-stop-detector:stop_detector --video_path ./021_1.mp4
# для RTSP потока
docker run rtk-stop-detector:stop_detector --rtsp_url 'rtsp://admin:lavrentiev6@10.2.21.221/cam/realmonitor?channel=1&subtype=1' --drawing_mode 0
```

# Документация для класса `StopDetector`

## Описание
Класс `StopDetector` предназначен для обработки видео и изображений с использованием модели ONNX. Он включает методы для предобработки изображений, выполнения инференса, постобработки результатов и обработки видео. Класс также использует трекер `SFSORT` для отслеживания объектов.

---

## Импорты
- **os**: Для работы с файловой системой (создание, удаление, перемещение файлов и папок).
- **cv2 (OpenCV)**: Для работы с изображениями и видео.
- **NumPy (np)**: Для работы с многомерными массивами и матричными вычислениями.
- **json**: Для сериализации и десериализации JSON-данных.
- **json_Create (JsonFileProcessor)**: Пользовательский модуль для обработки JSON-файлов.
- **collections (defaultdict, deque)**: 
  - `defaultdict`: Расширение словаря, создающее значения по умолчанию.
    - *Пример*: `data = defaultdict(list)`
  - `deque`: Быстрая очередь с возможностью добавления и удаления элементов с обоих концов.
- **time**: Для работы со временем (задержки, измерение времени выполнения и др.).
- **Timer (Timer)**: Пользовательский модуль для измерения времени выполнения операций.
- **base_detector (BaseDetector)**: Базовый класс для детекторов объектов.
- **utils_V3**: Пользовательский модуль с функциями для работы с изображениями, секторами и данными:
  - `get_sector`: Определение сектора для объекта.
  - `draw_grid`: Рисование сетки на изображении.
  - `draw_count_in_sectors`: Отображение количества объектов в секторах.
  - `draw_bounding_box`: Рисование ограничивающей рамки вокруг объектов.
  - `draw_direction_vector`: Отображение вектора направления объектов.
  - `process_Stop_objects`: Обработка объектов, находящихся в состоянии "стоп".
  - `update_sector_speed_data`: Обновление данных о скорости в секторах.
  - `clear_directory`: Очистка указанной директории.
  - `calculate_time_total`: Вычисление общего времени обработки.

---

## Параметры трекера SFSORT
Параметры для трекера `SFSORT` задаются в словаре `tracker_args_sfsort`. Основные параметры:
- `high_th`: Порог для высокоуверенных детекций.
- `match_th_first`: Порог для первого этапа сопоставления.
- `low_th`: Порог для низкоуверенных детекций.
- `new_track_th`: Порог для создания нового трека.
- `dynamic_tuning`: Включение динамической настройки параметров.
- `cth`: Порог для динамической настройки.
- `marginal_timeout`, `central_timeout`: Таймауты для треков.
- `horizontal_margin`, `vertical_margin`: Отступы для треков.
- `frame_width`, `frame_height`: Размеры кадра.

---

### Методы

#### `__init__(self, model_path="./model/yolov8s.onnx")`
Инициализация объекта с параметрами для детекции, отслеживания и сохранения информации.

**Параметры:**
- `model_path`: Путь к модели ONNX (по умолчанию `"./model/yolov8s.onnx"`).

**Инициализация:**
- `self.model`: Объект модели нейронной сети.
- `self.timers`: Словарь таймеров для отслеживания времени.
- `self.track_history`: Словарь для хранения истории изменения трэка объектов.
- `self.sector_time_history`: Словарь для хранения времени нахождения объектов в разных секторах.
- `self.green_bboxes`, `self.yellow_bboxes`, `self.red_bboxes`: Словари для хранения информации о bounding boxes разных цветов.
- `self.car_stop_time`, `self.color_stop_time`: Словари для отслеживания времени остановки объектов с разными состояниями.
- `self.colorChange`, `self.colorChangeBool`: Словари для отслеживания изменений цвета объектов.
- `self.red_dir`, `self.yellow_dir`: Папки для хранения объектов с длительным и кратким временем стоянки.
- `self.time_stop`: Время, в течение которого объект находится в состоянии остановки.
- `self.drawing_mode`: Режим разметки (True/False).
- `self.region_count`: Количество зон разметки (по умолчанию 10).
- `self.grid_size`: Размер сетки для деления экрана.
- `self.video_record`: Флаг для записи видео (True/False).
- `self.frame_size`: Размер кадра видео (по умолчанию (1280, 720)).
- `self.frame_skip`: Флаг для пропуска кадров.
- `self.alarm_time`: Время для покраски объекта в желтый цвет.
- `self.timePark`, `self.output_interval`, `self.TimeFolder_stop`, `self.JsonWrite_stop`, `self.CropWrite_stop`, `self.TimeFolder_park`, `self.JsonWrite_park`, `self.CropWrite_park`: Параметры для управления временем и сохранением файлов в папки для различных состояний объектов.
- `self.frame_to_avg`: Количество кадров для усреднения.
- `self.MaxLen`: Максимальная длина массивов.
- `self.time_Total`: Инициализация переменной общего времени.
- `self.count_reset`: Сброс счетчика в секторах.
- `self.sector_size`: Размер сектора сетки.
- `self.sector_speed_data`: Инициализация данных о скорости объектов в секторах.
- `self.polygon_points`: Инициализация точек для разметки.
- `self.color`: Цвет объектов по умолчанию (белый).

---

#### `get_object_color(self, track_id, alarm_time, timePark, elapsed_time, norm_vector_length, current_sector, MaxLen)`
Определяет цвет объекта на основе его состояния, времени нахождения в секторе.

**Параметры:**
- `track_id`: Уникальный идентификатор объекта.
- `alarm_time`: Время, по прошествии которого объект будет окрашен в желтый цвет.
- `timePark`: Время нахождения объекта более длительное время.
- `elapsed_time`: Время, прошедшее с момента последнего обновления.
- `norm_vector_length`: Нормализованная длина вектора, связанная с движением объекта.
- `current_sector`: Текущий сектор, в котором находится объект.
- `MaxLen`: Максимальная длина для ограничения словарей (где хранятся bounding boxes).

**Логика работы:**
1. Ограничивает длину словарей `green_bboxes`, `yellow_bboxes`, `red_bboxes` с помощью метода `update_dict_maxlen`, чтобы избежать переполнения.
2. Если объект находится в состоянии остановки (`time_stop > timePark`), он окрашивается в красный (`COLOR_RED`).
3. Если время нахождения объекта в секторе больше чем `elapsed_time`, либо объект уже был окрашен в желтый цвет, либо его движение слишком мало (меньше 0.02 по нормализованной длине вектора), объект окрасится в желтый (`COLOR_YELLOW`).
4. Если объект поменял свой сектор, он окрашивается в зеленый цвет (`COLOR_GREEN`).
5. В остальных случаях объект остаётся зеленым (`COLOR_GREEN`).

---

#### `update_dict_maxlen(self, dictionary, MaxLen)`
Обновляет словарь с ограничением длины записей.

**Параметры:**
- `dictionary`: Словарь, который необходимо обновить.
- `MaxLen`: Максимальная длина словаря. Если количество записей в словаре превышает это значение, то будет удалена самая старая запись.

**Логика работы:**
- Если количество записей в словаре больше, чем `MaxLen`, то удаляется самая старая запись (первая по порядку).
- Метод возвращает обновлённый словарь.

---

#### `check_alarm(self, car_stop_data)`
Обрабатывает данные об остановках автомобиля по секторам и возвращает словарь с временем остановки в каждом уникальном секторе.

**Параметры:**
- `car_stop_data`: Словарь, где ключи — это секторы, а значения — время остановки для каждого сектора.

**Возвращаемое значение:**
- Возвращает словарь, где ключи — это уникальные сектора, а значения — время остановки в этих секторах.

**Логика работы:**
1. Если входной словарь `car_stop_data` пустой, возвращается пустой словарь.
2. Инициализируется пустой словарь `current_time` для хранения времени остановки для каждого сектора.
3. Метод проходит по всем секторам в `car_stop_data`. Если текущий сектор отличается от предыдущего, добавляется его время остановки в `current_time`.
4. Возвращается итоговый словарь с уникальными секторами и временем их остановки.

---

#### `check_alarm_and_conditions(self, dict_alrm, threshold)`
Обрабатывает данные о срабатывании тревог на основе заданного порога и выполняет дополнительные проверки соседних секторов. Возвращает количество срабатываний.

**Параметры:**
- `dict_alrm`: Словарь с данными по секторам, где ключи — это сектора, а значения — времена срабатывания.
- `threshold`: Пороговое значение времени, выше которого считается срабатывание.

**Логика работы:**
1. Метод разделяет данные о срабатываниях тревог на блоки, если время срабатывания в секторе превышает заданный порог `threshold`.
2. Для каждого блока данных проверяется:
   - Если хотя бы одно значение времени в словаре превышает порог, и при этом существуют соседние сектора с меньшими значениями времени, то происходит срабатывание.
3. Для каждого блока, где выполняются эти условия, увеличивается счётчик срабатываний.
4. Метод возвращает общее количество срабатываний.

**Возвращаемое значение:**
- Возвращает количество срабатываний.

---

#### `clear_data(self)`
Очищает данные, связанные с таймерами, трекингом и цветами объектов, и инициализирует их заново.

**Логика работы:**
- Метод сбрасывает все важные данные, связанные с состоянием объектов, включая:
  - Таймеры (`self.timers`).
  - Историю трекинга объектов (`self.track_history`).
  - Историю времени нахождения объектов в секторах (`self.sector_time_history`).
  - Bounding boxes объектов различных цветов (`self.green_bboxes`, `self.yellow_bboxes`, `self.red_bboxes`).
  - Время остановки объектов (`self.car_stop_time`, `self.color_stop_time`).
  - Состояния изменения цвета объектов (`self.colorChange`, `self.colorChangeBool`).

- Все эти данные инициализируются заново с использованием `defaultdict` для работы с динамически добавляемыми ключами и значениями.

---

#### Основной метод обработки видео.
`run(self, video_path=None, time_Total=0, drawing_mode=1, region_count=10, grid_size=(32, 32), video_record=True, frame_size=(1280, 720), frame_skip=True, alarm_time=1.5, output_interval=5, TimeFolder_stop=10, JsonWrite_stop=True, CropWrite_stop=False, TimeFolder_park=10, JsonWrite_park=True, CropWrite_park=False, frame_to_avg=3, MaxLen=1000, count_reset=1000)`


**Параметры:**
- `video_path`: Путь к видеофайлу. По умолчанию `None`.
- `time_Total`: Общее время для подсчета.
- `drawing_mode`: Режим рисования (1 — рисовать, 0 — не рисовать). По умолчанию 0.
- `region_count`: Число зон разметки. По умолчанию 10.
- `grid_size`: Размер сетки для разделения кадра. По умолчанию (32, 32).
- `video_record`: Записывать ли видео с результатом. По умолчанию `True`.
- `frame_size`: Разрешение видео. По умолчанию (1280, 720).
- `frame_skip`: Пропуск кадров для ускорения обработки. По умолчанию `True`.
- `alarm_time`: Время, необходимое для покраски объекта в желтый цвет. По умолчанию 1.5.
- `output_interval`: Интервал записи файлов и их фильтрации в папку. По умолчанию 5.
- `TimeFolder_stop`: Время, с которого записываем кропы в папку Stop. По умолчанию 10.
- `JsonWrite_stop`: Сохраняем ли JSON в папку Stop. По умолчанию `True`.
- `CropWrite_stop`: Сохраняем ли crops в папку Stop. По умолчанию `False`.
- `TimeFolder_park`: Время, с которого записываем кропы в папку Park. По умолчанию 10.
- `JsonWrite_park`: Сохраняем ли JSON в папку Park. По умолчанию `True`.
- `CropWrite_park`: Сохраняем ли crops в папку Park. По умолчанию `False`.
- `frame_to_avg`: Число кадров для усреднения. По умолчанию 3.
- `MaxLen`: Максимальная длина словарей. По умолчанию 1000.
- `count_reset`: Сброс счетчика в секторах. По умолчанию 1000.

**Описание:**
Этот метод выполняет обработку видео, включая обработку кадров, работу с полигонами, отслеживание объектов, и изменение их цвета в зависимости от различных условий (например, время пребывания в секторе). Также поддерживается запись видео и сохранение данных в различные папки.

**Основные шаги:**
1. Инициализация параметров для обработки видео.
2. Загрузка полигонов и данных из JSON-файла для разметки зон.
3. Цикл обработки каждого кадра:
   - Проверка и пропуск кадров.
   - Обработка объектов, отслеживание их положения и времени пребывания в секторах.
   - Вычисление и обновление данных по времени парковки и движения.
4. Окрашивание объектов в зависимости от их состояния (зеленый, желтый, красный).
5. Запись видео и сохранение данных, если это указано в параметрах.

---

## Пример использования

```python
# Инициализация
python stopDetector.py --video_path './021.mp4' --drawing_mode 0

```

## Разметка видео

### Описание
Для разметки видео используется параметр `--drawing_mode 1`. Этот режим позволяет вручную выделять зоны на кадре и задавать время стоянки в этих зонах.

### Процесс разметки
1. **Файл для разметки**:  
   За процесс разметки отвечает файл `json_Create.py`, в котором используется класс `JsonFileProcessor` для создания и сохранения разметки в формате JSON.  
   В данном режиме откроется первый кадр видеопотока. Для начала разметки щёлкните левой кнопкой мыши. Чтобы замкнуть полигон, нажмите правую кнопку мыши. После этого программа запросит ввод времени длительной стоянки в секундах для данной области.  
   После указания времени вы можете завершить разметку, нажав клавишу **"q"**, или продолжить размечать следующую зону. Чтобы замкнуть следующий полигон, снова нажмите правую кнопку мыши и укажите время стоянки для этой зоны в секундах. Для выхода из режима разметки в любое время нажмите **"q"**.

2. **Ввод времени стоянки**:  
   Во время разметки необходимо ввести время стоянки для каждой зоны (Region). Например:  
   - Введите время стоянки для **Region_1** (в секундах): 5  
     После ввода, полигон **Region_1** успешно сохраняется.
   - Введите время стоянки для **Region_2** (в секундах): 10  
     После ввода, полигон **Region_2** успешно сохраняется.
   - После указания времени вы можете завершить разметку, нажав клавишу **"q"** 

3. **Формат JSON**:  
   После завершения разметки, файл `regions.json` будет содержать информацию о каждой зоне, включая координаты вершин полигона и время стоянки в каждой зоне.  
   

### Вид json файла с разметкой зон движения
```
{
    "url": "./Path",             // Локальный путь к видеофайлу
    "height": 720,                  // Высота видео 
    "width": 1280,                  // Ширина видео 
    "shapes": [                     // Список зон в видео
        {
            "label": "Region_1",    // Название зоны
            "points": [             // Координаты точек, определяющих зону
                [519.0, 706.0],     // Точка 1: (x, y)
                [294.0, 445.0],     // Точка 2: (x, y)
                [679.0, 326.0],     // Точка 3: (x, y)
                [1260.0, 640.0],    // Точка 4: (x, y)
                [1230.0, 698.0],    // Точка 5: (x, y)
                [519.0, 706.0]      // Возвращение к начальной точке
            ],
            "group_id": null,       // Идентификатор группы (отсутствует)
            "flags": 5              // Время остановки, связанное с этой зоной (в секундах)
        },
        {
            "label": "Region_2",    // Название зоны
            "points": [             // Координаты точек, определяющих зону
                [267.0, 442.0],     // Точка 1: (x, y)
                [86.0, 240.0],      // Точка 2: (x, y)
                [313.0, 206.0],     // Точка 3: (x, y)
                [617.0, 334.0],     // Точка 4: (x, y)
                [267.0, 442.0]      // Возвращение к начальной точке
            ],
            "group_id": null,       // Идентификатор группы (отсутствует)
            "flags": 10             // Время остановки, связанное с этой зоной (в секундах)
        }
    ]
}

```
Если JSON файл с разметкой был создан, то в последующих запусках детектора можно сразу применить эту разметку. 
Для этого при запуске программы используется параметр --drawing_mode 0.

## Выходные данные 

### Описание папок `Stop` и `Park`

В папках `Stop` и `Park` хранится выходная информация, связанная с различной продолжительностью остановки объектов.
- **Папка `Stop`**: содержит данные о событиях с небольшой длительностью остановки.  
- **Папка `Park`**: используется для хранения информации о событиях с длительным временем остановки.

1. **Время остановки**  
   Определяет продолжительность, после которой данные объекта сохраняются в соответствующую папку (`Stop` или `Park`).

2. **Формат данных**  
   - Обрезанные изображения объектов (кропы).  
   - JSON-файлы с аннотациями, включающими координаты, временные метки и флаги.

3. **Интервалы записи**  
   Настраиваются параметры, задающие, с какой периодичностью сохраняются кадры или данные, что позволяет оптимизировать обработку и экономить дисковое пространство.

Параметры времени установки задаются в основном методе обработки
`run(self, video_path=None, time_Total=0, drawing_mode=1, region_count=10, grid_size=(32, 32), 
video_record=True, frame_size=(1280, 720), frame_skip=True, 
alarm_time=1.5, 
output_interval=5, 
TimeFolder_stop=10, 
JsonWrite_stop=True, 
CropWrite_stop=False, 
TimeFolder_park=10, J
sonWrite_park=True, 
CropWrite_park=False, 
frame_to_avg=3, MaxLen=1000, count_reset=1000)`

- **Параметры остановки ТС:**
- `alarm_time: float` (по умолчанию `1.5`)  
  Время, необходимое для изменения цвета на жёлтый.
- `output_interval: int` (по умолчанию `5`)  
  Интервал записи файлов и их фильтрации в папку.
- `TimeFolder_stop: int` (по умолчанию `10`)  
  Время, начиная с которого сохраняются кропы в папку Stop.
- `JsonWrite_stop: bool` (по умолчанию `True`)  
  Флаг для сохранения JSON-файлов в папку Stop.
- `CropWrite_stop: bool` (по умолчанию `False`)  
  Флаг для сохранения кропов в папку Stop.
- `TimeFolder_park: int` (по умолчанию `10`)  
  Время, начиная с которого сохраняются кропы в папку Park.
- `JsonWrite_park: bool` (по умолчанию `True`)  
  Флаг для сохранения JSON-файлов в папку Park.
- `CropWrite_park: bool` (по умолчанию `False`)  
  Флаг для сохранения кропов в папку Park.


### Выходные данные

Выходные данные представляют собой JSON-объект, в котором ключи обозначают идентификаторы объектов (`id`), а значения содержат информацию о времени и зоне остановки объекта.

#### Структура данных
- **Ключ**:  
  Числовой идентификатор объекта (`id`), отслеживаемого в процессе анализа.

- **Значение**:  
  Объект с информацией о времени остановки и зоне, в которой произошло событие.  
  - `time: float` - время остановки объекта (в секундах).  
  - `region: int` - идентификатор зоны, в которой была зафиксирована остановка.

#### Пример
```json
{
    "0": {
        "time": 10.05,
        "region": 1
    },
    "1": {
        "time": 12.42,
        "region": 2
    }
}
```

### Режим записи видео

В режиме `video_record=True` после завершения работы детектора будет получен записанный видеофайл, 
который содержит разметку машин, информацию о времени остановки и размеченные зоны. 
Формат выходного видеофайла: `год-месяц-дата_час_минута_секунда`, например, `2025-01-28_10-49-29.mp4`.
